use std::str::FromStr;

use super::ast::*;
use crate::common::input_tag::DynamicInputTag;
use crate::utils;

grammar;

match {
  // Symbols
  "=",
  ":-",
  ":=",
  "(",
  ")",
  "[",
  "]",
  "{",
  "}",
  ";",
  ":",
  ",",
  "|",
  ".",
  "<:",
  "::",
  "$",
  "@",

  // Formula Operators
  "/\\", // /\
  "\\/", // \/
  "~",
  "=>",
  "∃",
  "∀",

  // Expression Operators
  "&&",
  "||",
  "^",
  "==",
  "!=",
  "<",
  ">",
  ">=",
  "<=",
  "+",
  "-",
  "*",
  "/",
  "%",
  "!",
  "as",
  "?",

  // Operators Keyword
  "and",
  "or",
  "not",
  "implies",
  "where",
  "if",
  "then",
  "else",
  "exists",
  "forall",
  "case",
  "is",
  "new",

  // Type
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "isize",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "usize",
  "f32",
  "f64",
  "char",
  "bool",
  "&str",
  "String",
  "Symbol",
  "DateTime",
  "Duration",
  "Entity",
  "Tensor",

  // Boolean keywords
  "true",
  "false",

  // Wildcard
  "_",

  // Keywords
  "import",
  "type",
  "const",
  "relation",
  "rel",
  "query",

  // Literals
  r"[a-zA-Z][a-zA-Z_0-9]*" => name,
  r"([a-zA-Z][a-zA-Z_0-9]*)\s*<\s*([a-zA-Z][a-zA-Z_0-9]*)(\s*,\s*([a-zA-Z][a-zA-Z_0-9]*))*\s*>" => specialized_name,
  r"-?[0-9]+" => int,
  r"-?[0-9]+(\.[0-9]+)(e-?[0-9]+)?" => float,
  r#""""((?:[^"])*)"""|"""((?:[\s\S]|\\.)*)"""|"((?:[^"\\]|\\.)*)""# => string,
  r#"s"[^"]*""# => symbol_string,
  r#"t"[^"]*""# => date_time_string,
  r#"d"[^"]*""# => duration_string,
  r#"'[^']*'"# => character,

  // Comments and Whitespaces
  r"[ \n\r]*" => { },
  r"//[^\n\r]*[\n\r]*" => { },
  r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },
}

/// ============================== ///
/// ========= Attributes ========= ///
/// ============================== ///

AttributeValueNode: AttributeValueNode = {
  <c: Constant> => AttributeValueNode::Constant(c),
  "[" <vs: Separated<AttributeValue, ",">> "]" => AttributeValueNode::List(vs),
  "(" <ts: Separated<AttributeValue, ",">> ")" => AttributeValueNode::Tuple(ts),
}

AttributeValue = Spanned<AttributeValueNode>;

AttributeArg: Result<AttributeValue, (Identifier, AttributeValue)> = {
  <c: AttributeValue> => Ok(c),
  <n: Identifier> "=" <c: AttributeValue> => Err((n, c)),
}

AttributeNode: AttributeNode = {
  "@" <name: Identifier> => AttributeNode {
    name,
    pos_args: vec![],
    kw_args: vec![],
  },
  "@" <name: Identifier> "(" <args: Separated<AttributeArg, ",">> ")" => {
    AttributeNode {
      name,
      pos_args: args.iter().filter_map(|a| match a {
        Ok(c) => Some(c.clone()),
        _ => None,
      }).collect(),
      kw_args: args.iter().filter_map(|a| match a {
        Err(a) => Some(a.clone()),
        _ => None,
      }).collect(),
    }
  }
}

Attribute = Spanned<AttributeNode>;

Attributes = <Attribute*>;

/// ==================================== ///
/// ========= Type Declaration ========= ///
/// ==================================== ///

TypeNode: TypeNode = {
  "i8" => TypeNode::I8,
  "i16" => TypeNode::I16,
  "i32" => TypeNode::I32,
  "i64" => TypeNode::I64,
  "i128" => TypeNode::I128,
  "isize" => TypeNode::ISize,
  "u8" => TypeNode::U8,
  "u16" => TypeNode::U16,
  "u32" => TypeNode::U32,
  "u64" => TypeNode::U64,
  "u128" => TypeNode::U128,
  "usize" => TypeNode::USize,
  "f32" => TypeNode::F32,
  "f64" => TypeNode::F64,
  "char" => TypeNode::Char,
  "bool" => TypeNode::Bool,
  "&str" => TypeNode::Str,
  "String" => TypeNode::String,
  "Symbol" => TypeNode::Symbol,
  "DateTime" => TypeNode::DateTime,
  "Duration" => TypeNode::Duration,
  "Entity" => TypeNode::Entity,
  "Tensor" => TypeNode::Tensor,
  <n: Name> => TypeNode::Named(n),
}

Type = Spanned<TypeNode>;

SubtypeDeclNode: SubtypeDeclNode = {
  <attrs: Attributes> "type" <n: Identifier> "<:" <t: Type> => {
    SubtypeDeclNode {
      attrs,
      name: n,
      subtype_of: t,
    }
  }
}

SubtypeDecl = Spanned<SubtypeDeclNode>;

AliasTypeDeclNode: AliasTypeDeclNode = {
  <attrs: Attributes> "type" <n: Identifier> "=" <t: Type> => {
    AliasTypeDeclNode {
      attrs,
      name: n,
      alias_of: t,
    }
  }
}

AliasTypeDecl = Spanned<AliasTypeDeclNode>;

ArgTypeBindingNode: ArgTypeBindingNode = {
  <n: Identifier> ":" <t: Type> => {
    ArgTypeBindingNode { name: Some(n), ty: t }
  },
  <t: Type> => {
    ArgTypeBindingNode { name: None, ty: t }
  }
}

ArgTypeBinding = Spanned<ArgTypeBindingNode>;

RelationTypeNode: RelationTypeNode = {
  <n: Identifier> "(" <ts: Separated<ArgTypeBinding, ",">> ")" => {
    RelationTypeNode {
      name: n,
      arg_types: ts,
    }
  },
}

pub RelationType = Spanned<RelationTypeNode>;

RelationTypeDeclNode: RelationTypeDeclNode = {
  <attrs: Attributes> "type" <rts: AtLeastOneSeparated<RelationType, ",">> => {
    RelationTypeDeclNode {
      attrs,
      rel_types: rts,
    }
  },
}

RelationTypeDecl = Spanned<RelationTypeDeclNode>;

EnumTypeDeclNode: EnumTypeDeclNode = {
  <attrs: Attributes> "type" <n: Identifier> "=" <ms: AtLeastTwoSeparatedStrict<EnumTypeMember, "|">> => {
    EnumTypeDeclNode {
      attrs,
      name: n,
      members: ms,
    }
  }
}

EnumTypeDecl = Spanned<EnumTypeDeclNode>;

EnumTypeMemberNode: EnumTypeMemberNode = {
  <n: Identifier> => {
    EnumTypeMemberNode {
      name: n,
      assigned_num: None,
    }
  },
  <n: Identifier> "=" <c: Constant> => {
    EnumTypeMemberNode {
      name: n,
      assigned_num: Some(c),
    }
  }
}

EnumTypeMember = Spanned<EnumTypeMemberNode>;

ADTSeparator = "|";

AlgebraicDataTypeDeclNode: AlgebraicDataTypeDeclNode = {
  <attrs: Attributes> "type" <name: Identifier> "=" ADTSeparator? <vs: AtLeastTwoSeparatedStrict<AlgebraicDataTypeVariant, ADTSeparator>> => {
    AlgebraicDataTypeDeclNode {
      attrs,
      name,
      variants: vs,
    }
  }
}

AlgebraicDataTypeDecl = Spanned<AlgebraicDataTypeDeclNode>;

AlgebraicDataTypeVariantNode: AlgebraicDataTypeVariantNode = {
  <constructor: Identifier> "(" <args: Separated<Type, ",">> ")" => {
    AlgebraicDataTypeVariantNode {
      constructor,
      args,
    }
  }
}

AlgebraicDataTypeVariant = Spanned<AlgebraicDataTypeVariantNode>;

TypeDeclNode: TypeDeclNode = {
  <s: SubtypeDecl> => TypeDeclNode::Subtype(s),
  <a: AliasTypeDecl> => TypeDeclNode::Alias(a),
  <r: RelationTypeDecl> => TypeDeclNode::Relation(r),
  <e: EnumTypeDecl> => TypeDeclNode::Enum(e),
  <a: AlgebraicDataTypeDecl> => TypeDeclNode::Algebraic(a),
}

TypeDecl = Spanned<TypeDeclNode>;

/// ======================================== ///
/// ========= Constant Declaration ========= ///
/// ======================================== ///

EntityNode: EntityNode = {
  <e: Expr> => EntityNode::Expr(e),
  <o: Object> => EntityNode::Object(o),
}

pub Entity = Spanned<EntityNode>;

ObjectNode: ObjectNode = {
  <functor: Identifier> "(" <args: Separated<Entity, ",">> ")" => {
    ObjectNode {
      functor,
      args,
    }
  }
}

Object = Spanned<ObjectNode>;

ConstAssignmentNode: ConstAssignmentNode = {
  <n: Identifier> ":" <t: Type> "=" <e: Entity> => {
    ConstAssignmentNode {
      name: n,
      ty: Some(t),
      value: e,
    }
  },
  <n: Identifier> "=" <e: Entity> => {
    ConstAssignmentNode {
      name: n,
      ty: None,
      value: e,
    }
  }
}

ConstAssignment = Spanned<ConstAssignmentNode>;

ConstDeclNode: ConstDeclNode = {
  <attrs: Attributes> "const" <assignments: AtLeastOneSeparatedStrict<ConstAssignment, ",">> => {
    ConstDeclNode {
      attrs,
      assignments,
    }
  }
}

ConstDecl = Spanned<ConstDeclNode>;

/// ======================================== ///
/// ========= Relation Declaration ========= ///
/// ======================================== ///

DefineSymbol = { ":-", "=" }

RelationKeyword = {
  "rel",
  "relation",
}

RelationDeclNode: RelationDeclNode = {
  <s: ConstantSetDecl> => RelationDeclNode::Set(s),
  <f: FactDecl> => RelationDeclNode::Fact(f),
  <r: RuleDecl> => RelationDeclNode::Rule(r),
}

RelationDecl: RelationDecl = Spanned<RelationDeclNode>;

TagNode: TagNode = {
  <f: Float> => TagNode(DynamicInputTag::Float(f)),
  <b: Bool> => TagNode(DynamicInputTag::Bool(b)),
}

Tag: Tag = Spanned<TagNode>;

ConstantNode: ConstantNode = {
  <i: Int> => ConstantNode::Integer(i),
  <f: Float> => ConstantNode::Float(f),
  <b: Bool> => ConstantNode::Boolean(b),
  <c: ConstantChar> => ConstantNode::Char(c),
  <s: ConstantString> => ConstantNode::String(s),
  <s: ConstantSymbol> => ConstantNode::Symbol(s),
  <s: ConstantDateTime> => ConstantNode::DateTime(s),
  <s: ConstantDuration> => ConstantNode::Duration(s),
}

Constant: Constant = Spanned<ConstantNode>;

ConstantOrVariable: ConstantOrVariable = {
  <c: Constant> => ConstantOrVariable::Constant(c),
  <v: Variable> => ConstantOrVariable::Variable(v),
}

ConstantTupleNode: ConstantTupleNode = {
  "(" <elems: Separated<ConstantOrVariable, ",">> ")" => ConstantTupleNode { elems },
  <c: ConstantOrVariable> => ConstantTupleNode { elems: vec![c] },
}

ConstantTuple: ConstantTuple = Spanned<ConstantTupleNode>;

ConstantSetTupleNode: ConstantSetTupleNode = {
  <tag: Tag> "::" <tuple: ConstantTuple> => {
    ConstantSetTupleNode { tag, tuple }
  },
  <tuple: ConstantTuple> => {
    ConstantSetTupleNode { tag: Tag::default_none(), tuple }
  }
}

ConstantSetTuple: ConstantSetTuple = Spanned<ConstantSetTupleNode>;

ConstantSetNode: ConstantSetNode = {
  "{" <tuples: Separated<ConstantSetTuple, ",">> "}" => {
    ConstantSetNode { tuples, is_disjunction: false }
  },
  "{" <tuples: AtLeastTwoSeparated<ConstantSetTuple, ";">> "}" => {
    ConstantSetNode { tuples, is_disjunction: true }
  }
}

ConstantSet: ConstantSet = Spanned<ConstantSetNode>;

ConstantSetDeclNode: ConstantSetDeclNode = {
  <attrs: Attributes> RelationKeyword <name: Identifier> DefineSymbol <set: ConstantSet> => {
    ConstantSetDeclNode { attrs, name, set }
  }
}

ConstantSetDecl: ConstantSetDecl = Spanned<ConstantSetDeclNode>;

FactDeclNode: FactDeclNode = {
  <attrs: Attributes> RelationKeyword <tag: Tag> "::" <a: Atom> => {
    FactDeclNode { attrs, tag, atom: a }
  },
  <attrs: Attributes> RelationKeyword <a: Atom> => {
    FactDeclNode { attrs, tag: Tag::default_none(), atom: a }
  }
}

FactDecl = Spanned<FactDeclNode>;

WildcardNode: WildcardNode = {
  "_" => WildcardNode
}

Wildcard = Spanned<WildcardNode>;

VariableNode: VariableNode = {
  <name: Identifier> => VariableNode { name },
}

Variable = Spanned<VariableNode>;

AtomNode: AtomNode = {
  <predicate: Identifier> "(" <args: Separated<Expr, ",">> ")" => {
    AtomNode { predicate, type_args: vec![], args }
  },
  <n: SpecializedPredicate> "(" <args: Separated<Expr, ",">> ")" => {
    let (predicate, type_arg_ids) = n;
    let type_args = type_arg_ids.into_iter().map(Type::from).collect();
    AtomNode { predicate, type_args, args }
  }
}

Atom = Spanned<AtomNode>;

Formula = ConjDisjFormula;

ConjDisjFormula = {
  CommaConjunctionFormula,
  ImpliesFormula,
}

CommaConjunctionNode: ConjunctionNode = {
  <args: AtLeastTwoSeparatedStrict<AnnotatedAtomFormula, ",">> => ConjunctionNode { args }
}

CommaConjunction = Spanned<CommaConjunctionNode>;

CommaConjunctionFormula: Formula = {
  <c: CommaConjunction> => Formula::Conjunction(c),
}

ImpliesKeyword = { "=>", "implies" }

ImpliesNode: ImpliesNode = {
  <left: DisjunctionFormula> ImpliesKeyword <right: DisjunctionFormula> => {
    ImpliesNode {
      left: Box::new(left),
      right: Box::new(right),
    }
  }
}

Implies = Spanned<ImpliesNode>;

ImpliesFormula = {
  <i: Implies> => Formula::Implies(i),
  DisjunctionFormula,
}

DisjunctionKeyword = { "\\/", "or" }

DisjunctionNode: DisjunctionNode = {
  <args: AtLeastTwoSeparatedStrict<ConjunctionFormula, DisjunctionKeyword>> => {
    DisjunctionNode { args }
  }
}

Disjunction = Spanned<DisjunctionNode>;

DisjunctionFormula = {
  <d: Disjunction> => Formula::Disjunction(d),
  ConjunctionFormula,
}

ConjunctionKeyword = { "/\\", "and" }

ConjunctionNode: ConjunctionNode = {
  <args: AtLeastTwoSeparatedStrict<AnnotatedAtomFormula, ConjunctionKeyword>> => {
    ConjunctionNode { args }
  }
}

Conjunction = Spanned<ConjunctionNode>;

ConjunctionFormula: Formula = {
  <c: Conjunction> => Formula::Conjunction(c),
  AnnotatedAtomFormula,
}

NegateKeyword = { "~", "not" }

NegAtomNode: NegAtomNode = {
  NegateKeyword <a: Atom> => NegAtomNode { atom: a },
}

NegAtom = Spanned<NegAtomNode>;

AnnotatedAtomFormula: Formula = {
  <n: NegAtom> => Formula::NegAtom(n),
  UnitFormula,
}

ComplexFormula: Formula = {
  CommaConjunctionFormula,
  <i: Implies> => Formula::Implies(i),
  <d: Disjunction> => Formula::Disjunction(d),
  <c: Conjunction> => Formula::Conjunction(c),
  <n: NegAtom> => Formula::NegAtom(n),
}

VariableOrWildcard: VariableOrWildcard = {
  <v: Variable> => VariableOrWildcard::Variable(v),
  <w: Wildcard> => VariableOrWildcard::Wildcard(w),
}

ReduceOpNode: ReduceOperatorNode = {
  "exists" => ReduceOperatorNode::Exists,
  "forall" => ReduceOperatorNode::Forall,
  <n: Identifier> => {
    match n.name() {
      "count" => ReduceOperatorNode::Count,
      "sum" => ReduceOperatorNode::Sum,
      "prod" => ReduceOperatorNode::Prod,
      "min" => ReduceOperatorNode::Min,
      "max" => ReduceOperatorNode::Max,
      "unique" => ReduceOperatorNode::Unique,
      x => ReduceOperatorNode::Unknown(x.to_string()),
    }
  },
  <n: Identifier> "<" <k: Int> ">" => {
    match n.name() {
      "top" => if k > 0 {
        ReduceOperatorNode::TopK(k as usize)
      } else {
        ReduceOperatorNode::Unknown(format!("top<{}>", k))
      },
      "categorical" => if k > 0 {
        ReduceOperatorNode::CategoricalK(k as usize)
      } else {
        ReduceOperatorNode::Unknown(format!("categorical<{}>", k))
      },
      x => ReduceOperatorNode::Unknown(x.to_string()),
    }
  }
}

ReduceOp = Spanned<ReduceOpNode>;

ReduceArgsFull: Vec<Variable> = {
  "[" <args: Separated<Variable, ",">> "]" => args,
}

ReduceArgs: Vec<Variable> = {
  <args: ReduceArgsFull?> => {
    match args {
      Some(args) => args,
      None => vec![],
    }
  }
}

ReduceLeft: Vec<VariableOrWildcard> = {
  <v: VariableOrWildcard> => vec![v],
  "(" <vs: AtLeastTwoSeparated<VariableOrWildcard, ",">> ")" => vs,
}

ReduceGroupBy: (Vec<VariableBinding>, Box<Formula>) = {
  "where" <bs: AtLeastOneSeparatedStrict<VariableBinding, ",">> ":" <f: Formula> => (bs, Box::new(f)),
}

ReduceAssignmentSymbol = { "=", ":=" }

ReduceNode: ReduceNode = {
  <vs: ReduceLeft> ReduceAssignmentSymbol <op: ReduceOp> <args: ReduceArgs> "(" <f: Formula> <g: ReduceGroupBy?> ")" => {
    ReduceNode {
      left: vs,
      operator: op,
      args: args,
      bindings: vec![],
      body: Box::new(f),
      group_by: g,
    }
  },
  <vs: ReduceLeft> ReduceAssignmentSymbol <op: ReduceOp> <args: ReduceArgs> "(" <bs: AtLeastOneSeparatedStrict<VariableBinding, ",">> ":" <f: Formula> <g: ReduceGroupBy?> ")" => {
    ReduceNode {
      left: vs,
      operator: op,
      args: args,
      bindings: bs,
      body: Box::new(f),
      group_by: g,
    }
  }
}

Reduce = Spanned<ReduceNode>;

ForallExistsReduceOpNode: ReduceOperatorNode = {
  "exists" => ReduceOperatorNode::Exists,
  "forall" => ReduceOperatorNode::Forall,
}

ForallExistsReduceOp = Spanned<ForallExistsReduceOpNode>;

ForallExistsReduceNode: ForallExistsReduceNode = {
  <negate: NegateKeyword?> <op: ForallExistsReduceOp> "(" <f: Formula> <g: ReduceGroupBy?> ")" => {
    ForallExistsReduceNode {
      negate: negate.is_some(),
      operator: op,
      bindings: vec![],
      body: Box::new(f),
      group_by: g,
    }
  },
  <negate: NegateKeyword?> <op: ForallExistsReduceOp> "(" <bs: AtLeastOneSeparatedStrict<VariableBinding, ",">> ":" <f: Formula> <g: ReduceGroupBy?> ")" => {
    ForallExistsReduceNode {
      negate: negate.is_some(),
      operator: op,
      bindings: bs,
      body: Box::new(f),
      group_by: g,
    }
  },
}

ForallExistsReduce = Spanned<ForallExistsReduceNode>;

UnitFormula: Formula = {
  "(" <f: ComplexFormula> ")" => f,
  <c: Constraint> => Formula::Constraint(c),
  <a: Atom> => Formula::Atom(a),
  <c: Case> => Formula::Case(c),
  <r: Reduce> => Formula::Reduce(r),
  <r: ForallExistsReduce> => Formula::ForallExistsReduce(r),
}

ConstraintNode: ConstraintNode = {
  <c: Spanned<ComparisonBinaryExprNode>> => {
    ConstraintNode { expr: Expr::Binary(c) }
  },
  <u: Spanned<UnaryExprNode>> => {
    ConstraintNode { expr: Expr::Unary(u) }
  }
}

Constraint = Spanned<ConstraintNode>;

CaseNode: CaseNode = {
  "case" <v: Variable> "is" <e: Entity> => {
    CaseNode {
      variable: v,
      entity: e,
    }
  }
}

Case = Spanned<CaseNode>;

VariableBindingNode: VariableBindingNode = {
  <name: Identifier> => VariableBindingNode { name, ty: None },
  "(" <name: Identifier> ":" <ty: Type> ")" => VariableBindingNode { name, ty: Some(ty) },
}

VariableBinding = Spanned<VariableBindingNode>;

Expr: Expr = IfThenElseExpr;

IfThenElseExprNode: IfThenElseExprNode = {
  "if" <cond: AndOrExpr> "then" <then_br: IfThenElseExpr> "else" <else_br: IfThenElseExpr> => {
    IfThenElseExprNode {
      cond: Box::new(cond),
      then_br: Box::new(then_br),
      else_br: Box::new(else_br),
    }
  },
  <cond: AndOrExpr> "?" <then_br: IfThenElseExpr> ":" <else_br: IfThenElseExpr> => {
    IfThenElseExprNode {
      cond: Box::new(cond),
      then_br: Box::new(then_br),
      else_br: Box::new(else_br),
    }
  }
}

IfThenElseExpr: Expr = {
  <i: Spanned<IfThenElseExprNode>> => Expr::IfThenElse(i),
  AndOrExpr,
}

AndOrBinaryOpNode: BinaryOpNode = {
  "&&" => BinaryOpNode::And,
  "||" => BinaryOpNode::Or,
  "^" => BinaryOpNode::Xor,
}

AndOrBinaryOp = Spanned<AndOrBinaryOpNode>;

AndOrBinaryExprNode: BinaryExprNode = {
  <op1: AndOrExpr> <op: AndOrBinaryOp> <op2: ComparisonExpr> => {
    BinaryExprNode {
      op,
      op1: Box::new(op1),
      op2: Box::new(op2),
    }
  }
}

AndOrExpr: Expr = {
  <e: Spanned<AndOrBinaryExprNode>> => Expr::Binary(e),
  ComparisonExpr,
}

ComparisonBinaryOpNode: BinaryOpNode = {
  "==" => BinaryOpNode::Eq,
  "!=" => BinaryOpNode::Neq,
  "<" => BinaryOpNode::Lt,
  "<=" => BinaryOpNode::Leq,
  ">" => BinaryOpNode::Gt,
  ">=" => BinaryOpNode::Geq,
}

ComparisonBinaryExprNode: BinaryExprNode = {
  <op1: AddSubExpr> <op: Spanned<ComparisonBinaryOpNode>> <op2: AddSubExpr> => {
    BinaryExprNode {
      op,
      op1: Box::new(op1),
      op2: Box::new(op2),
    }
  }
}

ComparisonExpr: Expr = {
  <c: Spanned<ComparisonBinaryExprNode>> => Expr::Binary(c),
  <m: AddSubExpr> => m,
}

AddSubBinaryOpNode: BinaryOpNode = {
  "+" => BinaryOpNode::Add,
  "-" => BinaryOpNode::Sub,
}

AddSubBinaryExprNode: BinaryExprNode = {
  <op1: AddSubExpr> <op: Spanned<AddSubBinaryOpNode>> <op2: MulDivModExpr> => {
    BinaryExprNode {
      op,
      op1: Box::new(op1),
      op2: Box::new(op2),
    }
  }
}

AddSubExpr: Expr = {
  <a: Spanned<AddSubBinaryExprNode>> => Expr::Binary(a),
  <u: MulDivModExpr> => u,
}

MulDivModBinaryOpNode: BinaryOpNode = {
  "*" => BinaryOpNode::Mul,
  "/" => BinaryOpNode::Div,
  "%" => BinaryOpNode::Mod,
}

MulDivModBinaryExprNode: BinaryExprNode = {
  <op1: MulDivModExpr> <op: Spanned<MulDivModBinaryOpNode>> <op2: UnaryExpr> => {
    BinaryExprNode {
      op,
      op1: Box::new(op1),
      op2: Box::new(op2),
    }
  }
}

MulDivModExpr: Expr = {
  <m: Spanned<MulDivModBinaryExprNode>> => Expr::Binary(m),
  <a: UnaryExpr> => a,
}

UnaryOpNode: UnaryOpNode = {
  "+" => UnaryOpNode::Pos,
  "-" => UnaryOpNode::Neg,
  "!" => UnaryOpNode::Not,
}

UnaryOp = Spanned<UnaryOpNode>;

TypeCastOpNode: UnaryOpNode = {
  "as" <ty: Type> => UnaryOpNode::TypeCast(ty),
}

TypeCastOp = Spanned<TypeCastOpNode>;

UnaryExprNode: UnaryExprNode = {
  <op: UnaryOp> <op1: UnitExpr> => {
    UnaryExprNode {
      op,
      op1: Box::new(op1),
    }
  },
  <op1: UnitExpr> <op: TypeCastOp> => {
    UnaryExprNode {
      op,
      op1: Box::new(op1),
    }
  }
}

UnaryExpr: Expr = {
  <u: Spanned<UnaryExprNode>> => Expr::Unary(u),
  <u: UnitExpr> => u,
}

ComplexExpr: Expr = {
  <i: Spanned<IfThenElseExprNode>> => Expr::IfThenElse(i),
  <a: Spanned<AndOrBinaryExprNode>> => Expr::Binary(a),
  <c: Spanned<ComparisonBinaryExprNode>> => Expr::Binary(c),
  <a: Spanned<AddSubBinaryExprNode>> => Expr::Binary(a),
  <m: Spanned<MulDivModBinaryExprNode>> => Expr::Binary(m),
  <u: Spanned<UnaryExprNode>> => Expr::Unary(u),
}

FunctionIdentifierNode: FunctionIdentifierNode = {
  <n: Identifier> => FunctionIdentifierNode { id: n },
}

FunctionIdentifier = Spanned<FunctionIdentifierNode>;

CallExprNode: CallExprNode = {
  "$" <f: FunctionIdentifier> "(" <args: Separated<Expr, ",">> ")" => {
    CallExprNode::new(f, args)
  }
}

CallExpr = Spanned<CallExprNode>;

NewExprNode: NewExprNode = {
  "new" <functor: Identifier> "(" <args: Separated<Expr, ",">> ")" => {
    NewExprNode {
      functor,
      args,
    }
  }
}

NewExpr = Spanned<NewExprNode>;

UnitExpr: Expr = {
  "(" <e: ComplexExpr> ")" => e,
  <w: Wildcard> => Expr::Wildcard(w),
  <c: Constant> => Expr::Constant(c),
  <v: Variable> => Expr::Variable(v),
  <c: CallExpr> => Expr::Call(c),
  <n: NewExpr> => Expr::New(n),
}

RuleHeadNode: RuleHeadNode = {
  <a: Atom> => {
    RuleHeadNode::Atom(a)
  },
  <atoms: AtLeastTwoSeparated<Atom, ConjunctionKeyword>> => {
    RuleHeadNode::Conjunction(atoms)
  },
  "{" <atoms: AtLeastTwoSeparated<Atom, ",">> "}" => {
    RuleHeadNode::Conjunction(atoms)
  },
  "{" <atoms: AtLeastTwoSeparated<Atom, ";">> "}" => {
    RuleHeadNode::Disjunction(atoms)
  },
}

RuleHead = Spanned<RuleHeadNode>;

RuleNode: RuleNode = {
  <head: RuleHead> DefineSymbol <body: Formula> => {
    RuleNode { head, body }
  }
}

pub Rule = Spanned<RuleNode>;

RuleDeclNode: RuleDeclNode = {
  <a: Attributes> RelationKeyword <tag: Tag> "::" <r: Rule> => {
    RuleDeclNode { attrs: a, tag, rule: r }
  },
  <a: Attributes> RelationKeyword <r: Rule> => {
    RuleDeclNode { attrs: a, tag: Tag::default_none(), rule: r }
  },
}

RuleDecl = Spanned<RuleDeclNode>;

/// ====================================== ///
/// ========= Import Declaration ========= ///
/// ====================================== ///

ImportFileNode: ImportFileNode = {
  <s: StringLiteral> => {
    ImportFileNode {
      file_path: s,
    }
  }
}

ImportFile = Spanned<ImportFileNode>;

ImportDeclNode: ImportDeclNode = {
  <a: Attributes> "import" <f: ImportFile> => {
    ImportDeclNode {
      attrs: a,
      import_file: f,
    }
  }
}

ImportDecl = Spanned<ImportDeclNode>;

/// ===================================== ///
/// ========= Query Declaration ========= ///
/// ===================================== ///

QueryNode: QueryNode = {
  <name: Identifier> => {
    QueryNode::Predicate(name)
  },
  <atom: Atom> => {
    QueryNode::Atom(atom)
  }
}

pub Query = Spanned<QueryNode>;

QueryKeyword = {
  "query",
}

QueryDeclNode: QueryDeclNode = {
  <a: Attributes> QueryKeyword <q: Query> => {
    QueryDeclNode {
      attrs: a,
      query: q,
    }
  },
}

QueryDecl = Spanned<QueryDeclNode>;

/// ==================================== ///
/// ========= Item Declaration ========= ///
/// ==================================== ///

pub Item: Item = {
  <i: ImportDecl> => Item::ImportDecl(i),
  <t: TypeDecl> => Item::TypeDecl(t),
  <c: ConstDecl> => Item::ConstDecl(c),
  <r: RelationDecl> => Item::RelationDecl(r),
  <q: QueryDecl> => Item::QueryDecl(q),
}

pub Items: Items = <Item*>;

/// ============================== ///
/// ========= Primitives ========= ///
/// ============================== ///

Name: String = name => (<>).to_string();

pub SpecializedPredicate: (Identifier, Vec<Identifier>) = {
  <start: @L> <s: specialized_name> <end: @R> => {
    // First get the name part
    let angle_id = s.find("<").unwrap(); // Split the string using `<`
    let name = s[0..angle_id].trim_end(); // The first part is the name
    let name_id = Identifier::from_span(start, start + name.len(), IdentifierNode { name: name.to_string() }); // Generate the identifier for name

    // Then get the args part
    let all_args_str = &s[angle_id + 1..];
    let arg_local_start_positions = std::iter::once(0)
      .chain(all_args_str.match_indices(",").map(|(i, _)| i + 1))
      .chain(std::iter::once(all_args_str.len()))
      .collect::<Vec<_>>();
    let num_args = arg_local_start_positions.len() - 1;
    let arg_ids = (0..num_args)
      .map(|i| {
        let (curr_begin, curr_end) = (arg_local_start_positions[i], arg_local_start_positions[i + 1] - 1);
        let curr_total = curr_end - curr_begin;
        let local_arg_str = &all_args_str[curr_begin..curr_end];
        let local_arg_start = curr_begin + (curr_total - local_arg_str.trim_start().len());
        let local_arg_end = curr_begin + local_arg_str.trim_end().len();
        let global_arg_start = start + (angle_id + 1) + local_arg_start;
        let global_arg_end = start + (angle_id + 1) + local_arg_end;
        Identifier::from_span(global_arg_start, global_arg_end, IdentifierNode { name: local_arg_str.trim().to_string() })
      })
      .collect();

    // Return
    (name_id, arg_ids)
  }
}

IdentifierNode: IdentifierNode = <name: Name> => IdentifierNode { name };

Identifier = Spanned<IdentifierNode>;

Int: i64 = int => i64::from_str(<>).unwrap();

Float: f64 = float => f64::from_str(<>).unwrap();

StringLiteral: String = {
  <s: string> => {
    s[1..s.len() - 1].replace("\"\"", "")
                     .replace("\\t", "\t")
                     .replace("\\r", "\r")
                     .replace("\\n", "\n")
                     .replace("\\0", "\0")
                     .replace("\\\"", "\"")
                     .replace("\\\'", "\'")
                     .replace("\\\\", "\\")
                     .into()
  }
}

SymbolLiteral: String = {
  <s: symbol_string> => {
    s[2..s.len() - 1].into()
  }
}

DateTimeLiteral: String = {
  <s: date_time_string> => {
    s[2..s.len() - 1].into()
  }
}

DurationLiteral: String = {
  <s: duration_string> => {
    s[2..s.len() - 1].into()
  }
}

CharLiteral: String = {
  <s: character> => {
    s[1..s.len() - 1].replace("\\t", "\t").replace("\\n", "\n").replace("\\'", "'").replace("\\\\", "\\").into()
  }
}

Bool: bool = {
  "true" => true,
  "false" => false,
}

ConstantCharNode: ConstantCharNode = {
  <c: CharLiteral> => {
    ConstantCharNode { character: c }
  }
}

ConstantChar = Spanned<ConstantCharNode>;

ConstantStringNode: ConstantStringNode = {
  <s: StringLiteral> => {
    ConstantStringNode { string: s }
  }
}

ConstantString = Spanned<ConstantStringNode>;

ConstantSymbolNode: ConstantSymbolNode = {
  <s: SymbolLiteral> => {
    ConstantSymbolNode { symbol: s }
  }
}

ConstantSymbol = Spanned<ConstantSymbolNode>;

ConstantDateTimeNode: Result<ConstantDateTimeNode, String> = {
  <s: DateTimeLiteral> => {
    match utils::parse_date_time_string(&s) {
      Some(v) => Ok(ConstantDateTimeNode { datetime: v }),
      None => Err(format!("Cannot parse date time `{}`", s)),
    }
  }
}

ConstantDateTime = Spanned<ConstantDateTimeNode>;

ConstantDurationNode: Result<ConstantDurationNode, String> = {
  <s: DurationLiteral> => {
    match utils::parse_duration_string(&s) {
      Some(v) => Ok(ConstantDurationNode { duration: v }),
      None => Err(format!("Cannot parse duration `{}`", s)),
    }
  }
}

ConstantDuration = Spanned<ConstantDurationNode>;

/// =========================== ///
/// ========= Helpers ========= ///
/// =========================== ///

Separated<E, S>: Vec<E> = {
  <rs: (<E> S)*> <e: E?> => rs.into_iter().chain(e.into_iter()).collect()
}

SeparatedStrict<E, S>: Vec<E> = {
  <rs: (<E> S)*> <e: E> => rs.into_iter().chain(vec![e].into_iter()).collect()
}

AtLeastOneSeparated<E, S>: Vec<E> = {
  <r1: E> => vec![r1],
  <r1: E> <rs: (S <E>)+> S? => vec![vec![r1], rs].concat(),
}

AtLeastOneSeparatedStrict<E, S>: Vec<E> = {
  <r1: E> => vec![r1],
  <r1: E> <rs: (S <E>)+> => vec![vec![r1], rs].concat(),
}

AtLeastTwoSeparated<E, S>: Vec<E> = {
  <r1: E> <rs: (S <E>)+> S? => vec![vec![r1], rs].concat(),
}

AtLeastTwoSeparatedStrict<E, S>: Vec<E> = {
  <r1: E> <rs: (S <E>)+> => vec![vec![r1], rs].concat(),
}

Spanned<T>: AstNode<T> = {
  <start: @L> <t: T> <end: @R> => AstNode::from_span(start, end, t)
}
